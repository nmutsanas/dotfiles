-a file     true if file exists.
-b file     true if file exists and is a block special file.
-c file     true if file exists and is a character special file.
-d file     true if file exists and is a directory.
-e file     true if file exists.
-f file     true if file exists and is a regular file.
-g file     true if file exists and has its setgid bit set.
-h file     true if file exists and is a symbolic link.
-k file     true if file exists and has its sticky bit set.
-n string     true if length of string is non-zero.
-o option     true if option named option is on. option may be a single character, in which case it is a single letter option name. (See Specifying Options.)
-p file     true if file exists and is a FIFO special file (named pipe).
-r file     true if file exists and is readable by current process.
-s file     true if file exists and has size greater than zero.
-t fd     true if file descriptor number fd is open and associated with a terminal device. (note: fd is not optional)
-u file     true if file exists and has its setuid bit set.
-w file     true if file exists and is writable by current process.
-x file     true if file exists and is executable by current process. If file exists and is a directory, then the current process has permission to search in the directory.
-z string     true if length of string is zero.
-L file     true if file exists and is a symbolic link.
-O file     true if file exists and is owned by the effective user ID of this process.
-G file     true if file exists and its group matches the effective group ID of this process.
-S file     true if file exists and is a socket.
-N file     true if file exists and its access time is not newer than its modification time.
file1 -nt file2     true if file1 exists and is newer than file2.
file1 -ot file2     true if file1 exists and is older than file2.
file1 -ef file2     true if file1 and file2 exist and refer to the same file.
string = pattern
string == pattern     true if string matches pattern. The ‘==’ form is the preferred one. The ‘=’ form is for backward compatibility and should be considered obsolete.
string != pattern     true if string does not match pattern.
string =~ regexp     true if string matches the regular expression regexp. If the option RE_MATCH_PCRE is set regexp is tested as a PCRE regular expression using the zsh/pcre module, else it is tested as a POSIX extended regular expression using the zsh/regex module. Upon successful match, some variables will be updated; no variables are changed if the matching fails.
If the option BASH_REMATCH is not set the scalar parameter MATCH is set to the substring that matched the pattern and the integer parameters MBEGIN and MEND to the index of the start and end, respectively, of the match in string, such that if string is contained in variable var the expression ‘${var[$MBEGIN,$MEND]}’ is identical to ‘$MATCH’. The setting of the option KSH_ARRAYS is respected. Likewise, the array match is set to the substrings that matched parenthesised subexpressions and the arrays mbegin and mend to the indices of the start and end positions, respectively, of the substrings within string. The arrays are not set if there were no parenthesised subexpresssions. For example, if the string ‘a short string’ is matched against the regular expression ‘s(...)t’, then (assuming the option KSH_ARRAYS is not set) MATCH, MBEGIN and MEND are ‘short’, 3 and 7, respectively, while match, mbegin and mend are single entry arrays containing the strings ‘hor’, ‘4’ and ‘6’, respectively.
If the option BASH_REMATCH is set the array BASH_REMATCH is set to the substring that matched the pattern followed by the substrings that matched parenthesised subexpressions within the pattern.
string1 < string2     true if string1 comes before string2 based on ASCII value of their characters.
string1 > string2     true if string1 comes after string2 based on ASCII value of their characters.
exp1 -eq exp2     true if exp1 is numerically equal to exp2. Note that for purely numeric comparisons use of the ((...)) builtin described in Arithmetic Evaluation is more convenient than conditional expressions.
exp1 -ne exp2     true if exp1 is numerically not equal to exp2.
exp1 -lt exp2     true if exp1 is numerically less than exp2.
exp1 -gt exp2     true if exp1 is numerically greater than exp2.
exp1 -le exp2     true if exp1 is numerically less than or equal to exp2.
exp1 -ge exp2     true if exp1 is numerically greater than or equal to exp2.
( exp )     true if exp is true.
! exp     true if exp is false.
exp1 && exp2     true if exp1 and exp2 are both true.
exp1 || exp2     true if either exp1 or exp2 is true.
-z ${myvar// }   true if myvar is empty or only contains spaces
